(function () {
	'use strict';

	let _nls = null;
	let _locale = null;
	let _templatables = {};

	class Core {
		
	    static get nls() { return _nls; }
		
	    static set nls(value) { _nls = value; }
		
	    static get locale() { return _locale; }
		
	    static set locale(value) { _locale = value; }
		
		static Nls(id, subs, locale) {
			if (!this.nls) throw new Error("Nls content not set.");
			
			var itm = this.nls[id];

			if (!itm) throw new Error("Nls String '" + id + "' undefined.");

			var txt = itm[(locale) ? locale : this.locale];

			if (txt === undefined || txt === null) throw new Error("String does not exist for requested language.");

			return this.Format(txt, subs);
		}
			
		static Defer() {
			var defer = {};
			
			defer.promise = new Promise((resolve, reject) => {
				defer.Resolve = (result) => { resolve({ result:result }); };
				defer.Reject = (error) => { reject({ error:error }); };
			});
			
			return defer;
		}
		
		static Templatable(id, definition) {
			if (definition) {
				if (_templatables[id]) throw new Error(`Templatable ${id} is defined multiple times.`);
				
				else _templatables[id] = definition;
			}
			else if (!_templatables[id]) throw new Error(`Templatable ${id} is not defined.`);
			
			return _templatables[id];
		}
		
		static Templated(namespace) {
			var templated = [];
			
			for (var id in _templatables) {
				if (id.match(namespace)) templated.push(_templatables[id]);
			}
			
			return templated;
		}
	}

	class Net {
		
		static Request(url, success, failure) {
			var xhttp = new XMLHttpRequest();
			
			xhttp.onreadystatechange = function() {
				if (this.readyState != 4) return;
			
				// TODO : Switched to this.response, check if it breaks anything
				if (this.status == 200) success(this.response);
				
				else failure({ status:this.status, response:this.response });
			};
			
			xhttp.open("GET", url, true);
			
			xhttp.send();
		}
		
		static GetUrlParameter (name) {				
			name = name.replace(/[\[\]]/g, '\\$&');
			
			var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
			
			results = regex.exec(window.location.href);
			
			if (!results) return null;
			
			if (!results[2]) return '';
			
			return decodeURIComponent(results[2].replace(/\+/g, ' '));
		}
		
		static Download(name, content) {
			var link = document.createElement("a");
			
			link.href = "data:application/octet-stream," + encodeURIComponent(content);
			link.download = name;
			link.click();
			link = null;
		}
	}

	class Util {
		
		static Mixin(a, b) {				
			for (var key in b) {
				if (b.hasOwnProperty(key)) a[key] = b[key];
			}

			return arguments[0];
		}
		
		static Debounce(delegate, threshold) {
			var timeout;
		
			return function debounced () {
				
				function delayed () {
					delegate.apply(this, arguments);
					
					timeout = null; 
				}
		 
				if (timeout) clearTimeout(timeout);
		 
				timeout = setTimeout(delayed.bind(this), threshold || 100); 
			};
		}
		
		static Format(str, subs) {
			if (!subs || subs.length == 0) return str;
			
			var s = str;

			for (var i = 0; i < subs.length; i++) {
				var reg = new RegExp("\\{" + i + "\\}", "gm");
				s = s.replace(reg, subs[i]);
			}

			return s;
		}
	}

	class Dom {
		
		static Node(pNode, selector) {
			return pNode.querySelectorAll(selector).item(0) || null;
		}

		static Create(tagName, options, pNode) {
			var elem = document.createElement(tagName);
			
			Util.Mixin(elem, options);
			
			this.Place(elem, pNode);
			
			return elem
		}

		static CreateSVG(tagName, options, pNode) {
			var elem = document.createElementNS("http://www.w3.org/2000/svg", tagName);
			
			for (var id in options) elem.setAttribute(id, options[id]);
			
			this.Place(elem, pNode);
			
			return elem;
		}

		static CreateNS(ns, tagName, options, pNode) {
			var elem = document.createElementNS(ns, tagName);
			
			for (var id in options) elem.setAttribute(id, options[id]);
			
			this.Place(elem, pNode);
			
			return elem;
		}

		static Place(elem, pNode) {
			if (!!pNode) pNode.appendChild(elem);
		}

		static Replace(elem1, elem2) {
			var pNode = elem1.parentNode;
			
			pNode.insertBefore(elem2, elem1);

			this.Remove(elem1, pNode);
		}

		static Remove(elem, pNode) {
			if (!pNode.children.some(function(child) { return (child === elem); })) return;
			
			pNode.removeChild(elem);
		}

		static Empty(elem) {
			while (elem.firstChild) {
				elem.removeChild(elem.firstChild);
			}
		}

		static AddCss(domNode, css) {
			var c1 = domNode.className.split(" ");
			
			css.split(" ").forEach(function(c) {
				if (!c1.includes(c)) c1.push(c);
			});
			
			domNode.className = classes.join(" "); 
		}

		static RemoveCss(domNode, css) {				
			var c1 = domNode.className.split(" ");
			var c2 = css.split(" ");
			
			c1.filter(function(c) { return c2.indexOf(c) == -1; });
			
			domNode.className = classes.join(" "); 
		}

		static HasCss(domNode, css) {
			return (' ' + domNode.className + ' ').indexOf(' ' + css + ' ') > -1;
		}

		static SetCss(domNode, css) {
			domNode.className = css; 
		}

		static ToggleCss(domNode, css, enabled) {
			if (enabled) this.AddCss(domNode, css);
			
			else this.RemoveCss(domNode, css);
		}
		
		static GetAttribute(domNode, attr) {
			var attr = domNode.attributes.getNamedItem(attr);
			
			return attr ? attr.value : null;
		}
		
		static SetAttribute(domNode, attr, value) {
			domNode.setAttribute(attr, value);
		}
		
		static Geometry(node) {
			var style = window.getComputedStyle(node);
			
			var h = +(style.getPropertyValue("height").slice(0, -2));
			var w = +(style.getPropertyValue("width").slice(0, -2));
			var pL = +(style.getPropertyValue("padding-left").slice(0, -2));
			var pR = +(style.getPropertyValue("padding-right").slice(0, -2));
			var pT = +(style.getPropertyValue("padding-top").slice(0, -2));
			var pB = +(style.getPropertyValue("padding-bottom").slice(0, -2));
			
			var w = w - pL - pR;
			var h = h - pT - pB;
			
			// Use smallest width as width and height for square grid that fits in container
			// var s = w < h ? w : h;
			
			return { w : w , h : h }
		}
	}

	class Evented { 

		constructor() {
			this.listeners = {};
		}

		addEventListener(type, callback, once){
			if (!(type in this.listeners)) this.listeners[type] = [];
			
			var h = { target:this, type:type, callback:callback, once:!!once };
			
			this.listeners[type].push(h);
			
			return h;
		}
		
		removeEventListener(type, callback){
			if (!(type in this.listeners)) return;
		  
			var stack = this.listeners[type];
			  
			for (var i = 0, l = stack.length; i < l; i++){
				if (stack[i].callback === callback){
					stack.splice(i, 1);
					
					return this.removeEventListener(type, callback);
				}
			}
		}
		
		dispatchEvent(event){
			if (!(event.type in this.listeners)) return;

			var stack = this.listeners[event.type];

			event.target = this;

			for (var i = 0; i < stack.length; i++) {
				stack[i].callback.call(this, event);
			}
			
			for (var i = stack.length - 1; i >= 0; i--) {
				if (!!stack[i].once) this.removeEventListener(event.type, stack[i].callback);
			}
		}
		
		Emit(type, data) {
			var event = { type:type, bubbles:true, cancelable:true };
		
			Util.Mixin(event, data);
			
			this.dispatchEvent(event);
		}
		
		On(type, callback) {
			return this.addEventListener(type, callback, false);
		}

		Once(type, callback) {
			return this.addEventListener(type, callback, true);
		}

		Off(type, callback) {
			this.removeEventListener(type, callback);
		}
	}

	class Templated extends Evented { 

		constructor(container, options) {
			super();
			
			this.options = options || { };
			
			this.BuildTemplate();
			
			if (this.template) this.SetNamedNodes();
		
			if (this.template) this.BuildSubWidgets();
			
			if (container) this.Place(container);
		}
		
		BuildTemplate() {
			// Use template provided in options first, use Template function second
			var html = this.options.template ? this.options.template : this.Template();
			
			// TODO : I think it still works with empty templates.
			if (!html) return;
			
			// Trailing whitespaces can cause issues when parsing the template, remove them
			html = html.trim();
			
			// Replace all nls strings in template. Nls string pattern in templates is nls(StringId)
			html = this.Replace(html, /nls\((.*?)\)/, function(m) { return Core.Nls(m); });
			
			this.template = Dom.Create("template", { innerHTML:html });
		}
		
		SetNamedNodes() {		
			var named = this.template.content.querySelectorAll("[handle]");
			
			this.nodes = {};
			
			// Can't use Array ForEach here since named is a NodeList, not an array
			for (var i = 0; i < named.length; i++) { 
				var name = Dom.GetAttribute(named[i], "handle");
				
				this.nodes[name] = named[i];
			}
		}
		
		BuildSubWidgets() {
			var nodes = this.template.content.querySelectorAll("[widget]");
			
			// Can't use Array ForEach here since nodes is a NodeList, not an array
			for (var i = 0; i < nodes.length; i++) {
				var path = Dom.GetAttribute(nodes[i], "widget");
				var module = Core.Templatable(path);
				var widget = new module(nodes[i]);
				var handle = Dom.GetAttribute(widget.container, "handle");
				
				if (handle) this.nodes[handle] = widget;
			}
		}
		
		Place(container) {
			this.container = container;
			
			if (!this.template) return;
			
			while (this.template.content.children.length > 0) {
				Dom.Place(this.template.content.children[0], this.container);
			}
		}
		
		Template() {
			return null;		
		}

		Replace(str, expr, delegate) {
			var m = str.match(expr);
			
			while (m) {
				str = str.replace(m[0], delegate(m[1]));
				m = str.match(expr);
			}
			
			return str;
		}
		
		Node(id) {
			return this.nodes[id];
		}
	}

	class Popup extends Templated { 
		
		set Widget(value) {
			this.widget = value;
			
			this.widget.Place(this.Node("body"));
		}
		
		get Widget() { return this.widget; }
		
		constructor() {	
			super(document.body);
			
			this.widget = null;
			
			this.Node("close").addEventListener("click", this.onBtnClose_Click.bind(this));
			
			this.Hide();
		}
			
		Show() {
			this.Node("root").style.opacity = 1;
			this.Node("root").style.visibility = "visible";
		}
		
		Hide() {
			this.Node("root").style.opacity = 0;
			this.Node("root").style.visibility = "hidden";
		}
		
		onBtnClose_Click(ev) {
			this.Hide();
		}
		
		Template() {
			return "<div handle='root' class='popup'>" +
					  "<div class='popup-container'>" +
						  "<div class='popup-header'>" +
							  "<div class='popup-title' handle='title'></div>" +
							  "<button class='close' handle='close'>×</button>" +
						  "</div>" +
						
						  "<div class='popup-body' handle='body'></div>" +
					  "</div>" +
				  "</div>";
		}
	}

	var Tooltip = Core.Templatable("UI.Tooltip", class Tooltip {
		
		constructor(container) {				

		}
		
		Template() {
			return '<div handle="root" class="tooltip">' +
					  '<div handle="content"></div>' +
				   '</div>';
		}
		
		PositionTarget(target, offset) {
			offset = offset || [0,0];
			
			bbox1 = target.getBoundingClientRect();
			bbox2 = this.Node("root").getBoundingClientRect();
			
			var x = bbox1.left +  bbox1.width / 2 - bbox2.width / 2 + offset[0];
			var y = bbox1.top + document.documentElement.scrollTop - bbox2.height - 5  + offset[1];
			
			this.PositionXY(x, y);
		}
		
		PositionXY(x, y) {
			this.Node("root").style.left = x + "px";
			this.Node("root").style.top = y + "px";
					
			if (this.BBox.left + this.BBox.width > window.innerWidth) {
				this.Node("root").style.top = y + 30 + "px";
				this.Node("root").style.left = -180 + x + "px";
			}
		}
		
		Show(x, y) {
			this.PositionXY(x, y);
			
			this.Node("root").style.opacity = 1;
		}
		
		Hide() {
			this.Node("root").style.opacity = 0;
		}
		
		Empty() {
			Dom.Empty(this.Node("content"));
		}
		
		get BBox() {
			return this.Node("root").getBoundingClientRect();
		}
	});

	// Static tools

	class BT {
		
	    static get nls() { return Core.nls; }
		
	    static set nls(value) { Core.nls = value; }
		
	    static get locale() { return Core.locale; }
		
	    static set locale(value) { Core.locale = value; }
		
		static get Core() { return Core; }
		
		static get Net() { return Net; }
		
		static get Dom() { return Dom; }
		
		static get Util() { return Util; }
		
		static get Components() {
			return {
				Evented : Evented,
				Templated : Templated,
				Popup : Popup,
				Tooltip : Tooltip
			};
		}
	}

	// This is a workaround for ie11 because it doesn't support es6. The point is to wrap the 

	window.BT = BT;

}());
