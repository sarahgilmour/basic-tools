(function () {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  var _nls = null;
  var _locale = null;
  var _templatables = {};

  var Core =
  /*#__PURE__*/
  function () {
    function Core() {
      _classCallCheck(this, Core);
    }

    _createClass(Core, null, [{
      key: "Nls",
      value: function Nls(id, subs, locale) {
        if (!this.nls) throw new Error("Nls content not set.");
        var itm = this.nls[id];
        if (!itm) throw new Error("Nls String '" + id + "' undefined.");
        var txt = itm[locale ? locale : this.locale];
        if (txt === undefined || txt === null) throw new Error("String does not exist for requested language.");
        return this.Format(txt, subs);
      }
    }, {
      key: "Defer",
      value: function Defer() {
        var defer = {};
        defer.promise = new Promise(function (resolve, reject) {
          defer.Resolve = function (result) {
            resolve({
              result: result
            });
          };

          defer.Reject = function (error) {
            reject({
              error: error
            });
          };
        });
        return defer;
      }
    }, {
      key: "Templatable",
      value: function Templatable(id, definition) {
        if (definition) {
          if (_templatables[id]) throw new Error("Templatable ".concat(id, " is defined multiple times."));else _templatables[id] = definition;
        } else if (!_templatables[id]) throw new Error("Templatable ".concat(id, " is not defined."));

        return _templatables[id];
      }
    }, {
      key: "Templated",
      value: function Templated(namespace) {
        var templated = [];

        for (var id in _templatables) {
          if (id.match(namespace)) templated.push(_templatables[id]);
        }

        return templated;
      }
    }, {
      key: "nls",
      get: function get() {
        return _nls;
      },
      set: function set(value) {
        _nls = value;
      }
    }, {
      key: "locale",
      get: function get() {
        return _locale;
      },
      set: function set(value) {
        _locale = value;
      }
    }]);

    return Core;
  }();

  var Net =
  /*#__PURE__*/
  function () {
    function Net() {
      _classCallCheck(this, Net);
    }

    _createClass(Net, null, [{
      key: "Request",
      value: function Request(url, success, failure) {
        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {
          if (this.readyState != 4) return; // TODO : Switched to this.response, check if it breaks anything

          if (this.status == 200) success(this.response);else failure({
            status: this.status,
            response: this.response
          });
        };

        xhttp.open("GET", url, true);
        xhttp.send();
      }
    }, {
      key: "GetUrlParameter",
      value: function GetUrlParameter(name) {
        name = name.replace(/[\[\]]/g, '\\$&');
        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        results = regex.exec(window.location.href);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
      }
    }, {
      key: "Download",
      value: function Download(name, content) {
        var link = document.createElement("a");
        link.href = "data:application/octet-stream," + encodeURIComponent(content);
        link.download = name;
        link.click();
        link = null;
      }
    }]);

    return Net;
  }();

  var Util =
  /*#__PURE__*/
  function () {
    function Util() {
      _classCallCheck(this, Util);
    }

    _createClass(Util, null, [{
      key: "Mixin",
      value: function Mixin(a, b) {
        for (var key in b) {
          if (b.hasOwnProperty(key)) a[key] = b[key];
        }

        return arguments[0];
      }
    }, {
      key: "Debounce",
      value: function Debounce(delegate, threshold) {
        var timeout;
        return function debounced() {
          function delayed() {
            delegate.apply(this, arguments);
            timeout = null;
          }

          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(delayed.bind(this), threshold || 100);
        };
      }
    }, {
      key: "Format",
      value: function Format(str, subs) {
        if (!subs || subs.length == 0) return str;
        var s = str;

        for (var i = 0; i < subs.length; i++) {
          var reg = new RegExp("\\{" + i + "\\}", "gm");
          s = s.replace(reg, subs[i]);
        }

        return s;
      }
    }]);

    return Util;
  }();

  var Dom =
  /*#__PURE__*/
  function () {
    function Dom() {
      _classCallCheck(this, Dom);
    }

    _createClass(Dom, null, [{
      key: "Node",
      value: function Node(pNode, selector) {
        return pNode.querySelectorAll(selector).item(0) || null;
      }
    }, {
      key: "Create",
      value: function Create(tagName, options, pNode) {
        var elem = document.createElement(tagName);
        Util.Mixin(elem, options);
        this.Place(elem, pNode);
        return elem;
      }
    }, {
      key: "CreateSVG",
      value: function CreateSVG(tagName, options, pNode) {
        var elem = document.createElementNS("http://www.w3.org/2000/svg", tagName);

        for (var id in options) {
          elem.setAttribute(id, options[id]);
        }

        this.Place(elem, pNode);
        return elem;
      }
    }, {
      key: "CreateNS",
      value: function CreateNS(ns, tagName, options, pNode) {
        var elem = document.createElementNS(ns, tagName);

        for (var id in options) {
          elem.setAttribute(id, options[id]);
        }

        this.Place(elem, pNode);
        return elem;
      }
    }, {
      key: "Place",
      value: function Place(elem, pNode) {
        if (!!pNode) pNode.appendChild(elem);
      }
    }, {
      key: "Replace",
      value: function Replace(elem1, elem2) {
        var pNode = elem1.parentNode;
        pNode.insertBefore(elem2, elem1);
        this.Remove(elem1, pNode);
      }
    }, {
      key: "Remove",
      value: function Remove(elem, pNode) {
        if (!pNode.children.some(function (child) {
          return child === elem;
        })) return;
        pNode.removeChild(elem);
      }
    }, {
      key: "Empty",
      value: function Empty(elem) {
        while (elem.firstChild) {
          elem.removeChild(elem.firstChild);
        }
      }
    }, {
      key: "AddCss",
      value: function AddCss(domNode, css) {
        var c1 = domNode.className.split(" ");
        css.split(" ").forEach(function (c) {
          if (!c1.includes(c)) c1.push(c);
        });
        domNode.className = classes.join(" ");
      }
    }, {
      key: "RemoveCss",
      value: function RemoveCss(domNode, css) {
        var c1 = domNode.className.split(" ");
        var c2 = css.split(" ");
        c1.filter(function (c) {
          return c2.indexOf(c) == -1;
        });
        domNode.className = classes.join(" ");
      }
    }, {
      key: "HasCss",
      value: function HasCss(domNode, css) {
        return (' ' + domNode.className + ' ').indexOf(' ' + css + ' ') > -1;
      }
    }, {
      key: "SetCss",
      value: function SetCss(domNode, css) {
        domNode.className = css;
      }
    }, {
      key: "ToggleCss",
      value: function ToggleCss(domNode, css, enabled) {
        if (enabled) this.AddCss(domNode, css);else this.RemoveCss(domNode, css);
      }
    }, {
      key: "GetAttribute",
      value: function GetAttribute(domNode, attr) {
        var attr = domNode.attributes.getNamedItem(attr);
        return attr ? attr.value : null;
      }
    }, {
      key: "SetAttribute",
      value: function SetAttribute(domNode, attr, value) {
        domNode.setAttribute(attr, value);
      }
    }, {
      key: "Geometry",
      value: function Geometry(node) {
        var style = window.getComputedStyle(node);
        var h = +style.getPropertyValue("height").slice(0, -2);
        var w = +style.getPropertyValue("width").slice(0, -2);
        var pL = +style.getPropertyValue("padding-left").slice(0, -2);
        var pR = +style.getPropertyValue("padding-right").slice(0, -2);
        var pT = +style.getPropertyValue("padding-top").slice(0, -2);
        var pB = +style.getPropertyValue("padding-bottom").slice(0, -2);
        var w = w - pL - pR;
        var h = h - pT - pB; // Use smallest width as width and height for square grid that fits in container
        // var s = w < h ? w : h;

        return {
          w: w,
          h: h
        };
      }
    }]);

    return Dom;
  }();

  var Evented =
  /*#__PURE__*/
  function () {
    function Evented() {
      _classCallCheck(this, Evented);

      this.listeners = {};
    }

    _createClass(Evented, [{
      key: "addEventListener",
      value: function addEventListener(type, callback, once) {
        if (!(type in this.listeners)) this.listeners[type] = [];
        var h = {
          target: this,
          type: type,
          callback: callback,
          once: !!once
        };
        this.listeners[type].push(h);
        return h;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        if (!(type in this.listeners)) return;
        var stack = this.listeners[type];

        for (var i = 0, l = stack.length; i < l; i++) {
          if (stack[i].callback === callback) {
            stack.splice(i, 1);
            return this.removeEventListener(type, callback);
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (!(event.type in this.listeners)) return;
        var stack = this.listeners[event.type];
        event.target = this;

        for (var i = 0; i < stack.length; i++) {
          stack[i].callback.call(this, event);
        }

        for (var i = stack.length - 1; i >= 0; i--) {
          if (!!stack[i].once) this.removeEventListener(event.type, stack[i].callback);
        }
      }
    }, {
      key: "Emit",
      value: function Emit(type, data) {
        var event = {
          type: type,
          bubbles: true,
          cancelable: true
        };
        Util.Mixin(event, data);
        this.dispatchEvent(event);
      }
    }, {
      key: "On",
      value: function On(type, callback) {
        return this.addEventListener(type, callback, false);
      }
    }, {
      key: "Once",
      value: function Once(type, callback) {
        return this.addEventListener(type, callback, true);
      }
    }, {
      key: "Off",
      value: function Off(type, callback) {
        this.removeEventListener(type, callback);
      }
    }]);

    return Evented;
  }();

  var Templated =
  /*#__PURE__*/
  function (_Evented) {
    _inherits(Templated, _Evented);

    function Templated(container, options) {
      var _this;

      _classCallCheck(this, Templated);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Templated).call(this));
      _this.options = options || {};

      _this.BuildTemplate();

      if (_this.template) _this.SetNamedNodes();
      if (_this.template) _this.BuildSubWidgets();
      if (container) _this.Place(container);
      return _this;
    }

    _createClass(Templated, [{
      key: "BuildTemplate",
      value: function BuildTemplate() {
        // Use template provided in options first, use Template function second
        var html = this.options.template ? this.options.template : this.Template(); // TODO : I think it still works with empty templates.

        if (!html) return; // Trailing whitespaces can cause issues when parsing the template, remove them

        html = html.trim(); // Replace all nls strings in template. Nls string pattern in templates is nls(StringId)

        html = this.Replace(html, /nls\((.*?)\)/, function (m) {
          return Core.Nls(m);
        });
        this.template = Dom.Create("template", {
          innerHTML: html
        });
      }
    }, {
      key: "SetNamedNodes",
      value: function SetNamedNodes() {
        var named = this.template.content.querySelectorAll("[handle]");
        this.nodes = {}; // Can't use Array ForEach here since named is a NodeList, not an array

        for (var i = 0; i < named.length; i++) {
          var name = Dom.GetAttribute(named[i], "handle");
          this.nodes[name] = named[i];
        }
      }
    }, {
      key: "BuildSubWidgets",
      value: function BuildSubWidgets() {
        var nodes = this.template.content.querySelectorAll("[widget]");

        for (var i = 0; i < nodes.length; i++) {
          var path = Dom.GetAttribute(nodes[i], "widget");
          var module = Core.Templatable(path);
          var widget = new module(nodes[i]);
          var handle = Dom.GetAttribute(widget.container, "handle");
          if (handle) this.nodes[handle] = widget;
        }
      }
    }, {
      key: "Place",
      value: function Place(container) {
        this.container = container;
        if (!this.template) return;

        while (this.template.content.children.length > 0) {
          Dom.Place(this.template.content.children[0], this.container);
        }
      }
    }, {
      key: "Template",
      value: function Template() {
        return null;
      }
    }, {
      key: "Replace",
      value: function Replace(str, expr, delegate) {
        var m = str.match(expr);

        while (m) {
          str = str.replace(m[0], delegate(m[1]));
          m = str.match(expr);
        }

        return str;
      }
    }, {
      key: "Node",
      value: function Node(id) {
        return this.nodes[id];
      }
    }]);

    return Templated;
  }(Evented);

  var Popup =
  /*#__PURE__*/
  function (_Templated) {
    _inherits(Popup, _Templated);

    _createClass(Popup, [{
      key: "Widget",
      set: function set(value) {
        this.widget = value;
        this.widget.Place(this.Node("body"));
      },
      get: function get() {
        return this.widget;
      }
    }]);

    function Popup() {
      var _this;

      _classCallCheck(this, Popup);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Popup).call(this, document.body));
      _this.widget = null;

      _this.Node("close").addEventListener("click", _this.onBtnClose_Click.bind(_assertThisInitialized(_this)));

      _this.Hide();

      return _this;
    }

    _createClass(Popup, [{
      key: "Show",
      value: function Show() {
        this.Node("root").style.opacity = 1;
        this.Node("root").style.visibility = "visible";
      }
    }, {
      key: "Hide",
      value: function Hide() {
        this.Node("root").style.opacity = 0;
        this.Node("root").style.visibility = "hidden";
      }
    }, {
      key: "onBtnClose_Click",
      value: function onBtnClose_Click(ev) {
        this.Hide();
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='popup'>" + "<div class='popup-container'>" + "<div class='popup-header'>" + "<div class='popup-title' handle='title'></div>" + "<button class='close' handle='close'>×</button>" + "</div>" + "<div class='popup-body' handle='body'></div>" + "</div>" + "</div>";
      }
    }]);

    return Popup;
  }(Templated);

  var Tooltip = Core.Templatable("UI.Tooltip",
  /*#__PURE__*/
  function () {
    function Tooltip(container) {
      _classCallCheck(this, Tooltip);
    }

    _createClass(Tooltip, [{
      key: "Template",
      value: function Template() {
        return '<div handle="root" class="tooltip">' + '<div handle="content"></div>' + '</div>';
      }
    }, {
      key: "PositionTarget",
      value: function PositionTarget(target, offset) {
        offset = offset || [0, 0];
        bbox1 = target.getBoundingClientRect();
        bbox2 = this.Node("root").getBoundingClientRect();
        var x = bbox1.left + bbox1.width / 2 - bbox2.width / 2 + offset[0];
        var y = bbox1.top + document.documentElement.scrollTop - bbox2.height - 5 + offset[1];
        this.PositionXY(x, y);
      }
    }, {
      key: "PositionXY",
      value: function PositionXY(x, y) {
        this.Node("root").style.left = x + "px";
        this.Node("root").style.top = y + "px";

        if (this.BBox.left + this.BBox.width > window.innerWidth) {
          this.Node("root").style.top = y + 30 + "px";
          this.Node("root").style.left = -180 + x + "px";
        }
      }
    }, {
      key: "Show",
      value: function Show(x, y) {
        this.PositionXY(x, y);
        this.Node("root").style.opacity = 1;
      }
    }, {
      key: "Hide",
      value: function Hide() {
        this.Node("root").style.opacity = 0;
      }
    }, {
      key: "Empty",
      value: function Empty() {
        Dom.Empty(this.Node("content"));
      }
    }, {
      key: "BBox",
      get: function get() {
        return this.Node("root").getBoundingClientRect();
      }
    }]);

    return Tooltip;
  }());

  var BT =
  /*#__PURE__*/
  function () {
    function BT() {
      _classCallCheck(this, BT);
    }

    _createClass(BT, null, [{
      key: "nls",
      get: function get() {
        return Core.nls;
      },
      set: function set(value) {
        Core.nls = value;
      }
    }, {
      key: "locale",
      get: function get() {
        return Core.locale;
      },
      set: function set(value) {
        Core.locale = value;
      }
    }, {
      key: "Core",
      get: function get() {
        return Core;
      }
    }, {
      key: "Net",
      get: function get() {
        return Net;
      }
    }, {
      key: "Dom",
      get: function get() {
        return Dom;
      }
    }, {
      key: "Util",
      get: function get() {
        return Util;
      }
    }, {
      key: "Components",
      get: function get() {
        return {
          Evented: Evented,
          Templated: Templated,
          Popup: Popup,
          Tooltip: Tooltip
        };
      }
    }]);

    return BT;
  }();

  // This is a workaround for ie11 because it doesn't support es6. The point is to wrap the 
  window.BT = BT;

}());
